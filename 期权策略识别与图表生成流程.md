# 期权策略识别与图表生成完整流程

**功能说明**: 在Chat Mode下，用户输入自然语言（如"我强烈看涨特斯拉"），系统自动识别投资意图，推荐期权策略，并生成可视化的Payoff曲线图表。

---

## 📊 完整数据流程图

```
用户输入聊天消息
    ↓
前端 App.js: sendMessage()
    ↓
POST /api/decisions/chat
    ↓
后端 app.py: chat() 函数
    ↓
[步骤1] 检测是否期权策略请求
    option_handler.is_option_strategy_request(message)
    ↓
[步骤2] 解析用户意图 (NLP)
    option_nlp_parser.parse(message)
    → 提取: ticker, direction, strength, timeframe, risk_profile
    ↓
[步骤3] 映射到具体策略
    option_strategy_mapper.map_strategy(intent, current_price)
    → 推荐策略, 计算参数, 生成payoff数据
    ↓
[步骤4] 返回JSON响应
    {
      "response": "文字描述",
      "option_strategy_used": true,
      "option_strategy_result": {...}
    }
    ↓
前端接收响应
    ↓
[步骤5] 显示策略模态框
    OptionStrategy.js 渲染
    ↓
[步骤6] 绘制Chart.js图表
    payoff_data → Chart.js 可视化
```

---

## 🔧 核心文件和功能

### 1. **后端 - NLP解析器** 
📄 `backend/algorithms/option_nlp_parser.py`

**功能**: 从自然语言中提取投资意图的关键字段

#### 核心类: `OptionParser`

```python
class OptionParser:
    def parse(self, user_input: str) -> ParsedIntent:
        """主解析函数"""
        intent = ParsedIntent()
        
        # 提取5个关键字段
        intent.ticker = self._extract_ticker(user_input)      # 股票代码
        intent.direction = self._extract_direction(text)      # 方向: bullish/bearish/neutral
        intent.strength = self._extract_strength(text)        # 强度: strong/moderate/slight  
        intent.timeframe = self._extract_timeframe(text)      # 时间: short/medium/long
        intent.risk_profile = self._extract_risk_profile(text) # 风险: aggressive/balanced/conservative
        intent.confidence = self._calculate_confidence(intent) # 置信度
        
        return intent
```

#### 关键字段识别逻辑:

**1. Ticker (股票代码) 识别**
```python
def _extract_ticker(self, text: str) -> Optional[str]:
    # 方法1: 中文名称映射
    ticker_map = {
        '特斯拉': 'TSLA',
        '苹果': 'AAPL',
        '英伟达': 'NVDA',
        # ... 更多映射
    }
    for name, ticker in ticker_map.items():
        if name in text:
            return ticker
    
    # 方法2: 正则匹配大写字母 (如 "TSLA")
    matches = re.findall(r'\b([A-Z]{2,5})\b', text)
    if matches:
        return matches[0]
```

**2. Direction (方向) 识别**
```python
direction_keywords = {
    'bullish': ['看涨', '看多', '上涨', '涨', '突破', 'long', 'call', '牛市'],
    'bearish': ['看跌', '看空', '下跌', '跌', 'short', 'put', '熊市'],
    'neutral': ['震荡', '横盘', '区间', 'neutral', '波动']
}

def _extract_direction(self, text: str) -> str:
    scores = {'bullish': 0, 'bearish': 0, 'neutral': 0}
    for direction, keywords in direction_keywords.items():
        for keyword in keywords:
            if keyword in text:
                scores[direction] += 1
    return max(scores, key=scores.get)  # 返回得分最高的
```

**3. Strength (强度) 识别**
```python
strength_keywords = {
    'strong': ['强烈', '非常', '极度', '大幅', '暴涨', '必定', '确信'],
    'moderate': ['可能', '应该', '预计', '温和', '适度', '一般'],
    'slight': ['略微', '小幅', '稍微', '轻微', '也许']
}
```

**4. Timeframe (时间) 识别**
```python
timeframe_keywords = {
    'short': ['短期', '近期', '本周', '本月', '1个月', '快速'],
    'medium': ['中期', '季度', '2-3个月', '几个月'],
    'long': ['长期', '年度', '半年', '一年', '长远']
}
```

**5. Risk Profile (风险偏好) 识别**
```python
risk_keywords = {
    'aggressive': ['激进', '赌', 'all in', '梭哈', '重仓', '高风险'],
    'balanced': ['平衡', '稳健', '适中', '中等', '均衡'],
    'conservative': ['保守', '稳妥', '安全', '低风险', '谨慎']
}
```

**6. 置信度计算**
```python
def _calculate_confidence(self, intent: ParsedIntent) -> float:
    confidence = 0.0
    if intent.ticker:        confidence += 0.3  # 必要字段
    if intent.direction:     confidence += 0.3  # 必要字段
    if intent.strength:      confidence += 0.15 # 可选字段
    if intent.timeframe:     confidence += 0.15 # 可选字段
    if intent.risk_profile:  confidence += 0.1  # 可选字段
    return min(confidence, 1.0)
```

#### 示例:

**输入**: `"我强烈看涨特斯拉股票"`

**输出**:
```python
ParsedIntent(
    ticker='TSLA',
    direction='bullish',
    strength='strong',
    timeframe='short',      # 默认值
    risk_profile='balanced', # 默认值
    confidence=0.75         # 0.3 + 0.3 + 0.15
)
```

---

### 2. **后端 - 策略映射器**
📄 `backend/algorithms/option_strategy_mapper.py`

**功能**: 根据解析的意图，推荐具体的期权策略并计算参数

#### 核心类: `StrategyMapper`

```python
class StrategyMapper:
    def map_strategy(self, intent: ParsedIntent, current_price: float) -> OptionStrategy:
        """映射策略的主函数"""
        
        # 1. 根据意图选择策略
        strategy_config = self._select_strategy(
            intent.direction,
            intent.strength,
            intent.risk_profile
        )
        
        # 2. 计算策略参数
        params = self._calculate_parameters(
            strategy_config['type'],
            current_price,
            intent.timeframe
        )
        
        # 3. 计算风险指标
        metrics = self._calculate_metrics(
            strategy_config['type'],
            params
        )
        
        # 4. 生成payoff曲线数据
        payoff_data = self._generate_payoff(
            strategy_config['type'],
            params
        )
        
        return OptionStrategy(...)
```

#### 策略映射规则 (32种组合):

```python
strategy_rules = {
    # (方向, 强度, 风险偏好): 策略配置
    ('bullish', 'strong', 'aggressive'): {
        'name': '买入平值看涨期权',
        'type': 'long_call',
        'description': '适合强烈看涨且愿意承担高风险的投资者。潜在收益无限。',
        'risk': '高'
    },
    ('bullish', 'strong', 'balanced'): {
        'name': '牛市价差',
        'type': 'bull_call_spread',
        'description': '买入较低执行价看涨期权，同时卖出较高执行价看涨期权。',
        'risk': '中'
    },
    ('bullish', 'strong', 'conservative'): {
        'name': '卖出虚值看跌期权',
        'type': 'sell_otm_put',
        'description': '卖出低于当前价的看跌期权，收取权利金。',
        'risk': '中低'
    },
    # ... 共32种组合
}
```

#### 参数计算示例 (牛市价差):

```python
def _calculate_parameters(self, strategy_type, current_price, timeframe):
    params = StrategyParameters(current_price=current_price)
    
    if strategy_type == 'bull_call_spread':
        params.buy_strike = current_price        # 买入执行价 = 当前价 (ATM)
        params.sell_strike = current_price * 1.10 # 卖出执行价 = 110% (OTM)
        params.premium_paid = current_price * 0.04    # 支付权利金 4%
        params.premium_received = current_price * 0.02 # 收到权利金 2%
        params.expiry = '30天' if timeframe == 'short' else '90天'
    
    return params
```

#### 风险指标计算:

```python
def _calculate_metrics(self, strategy_type, params):
    if strategy_type == 'bull_call_spread':
        net_premium = (params.premium_paid - params.premium_received) * 100
        max_loss = -net_premium  # 最大损失 = 净权利金
        max_gain = (params.sell_strike - params.buy_strike) * 100 - net_premium
        breakeven = params.buy_strike + (params.premium_paid - params.premium_received)
        probability = "45%"
    
    return StrategyMetrics(max_loss, max_gain, breakeven, probability)
```

#### Payoff曲线生成:

```python
def _generate_payoff(self, strategy_type, params):
    """生成101个点的payoff数据"""
    current_price = params.current_price
    payoff_data = []
    
    # 股价范围: 当前价格 ±30%
    for i in range(101):
        stock_price = current_price * 0.7 + (current_price * 0.6 / 100) * i
        
        # 计算该股价下的盈亏
        if strategy_type == 'bull_call_spread':
            # 买入Call的盈亏
            long_call_payoff = max(0, stock_price - params.buy_strike) - params.premium_paid
            # 卖出Call的盈亏
            short_call_payoff = params.premium_received - max(0, stock_price - params.sell_strike)
            # 总盈亏
            total_payoff = (long_call_payoff + short_call_payoff) * 100
        
        payoff_data.append({
            'price': round(stock_price, 2),
            'payoff': round(total_payoff, 2)
        })
    
    return payoff_data
```

---

### 3. **后端 - 策略处理器**
📄 `backend/option_strategy_handler.py`

**功能**: 整合NLP和策略映射，提供统一接口

```python
class OptionStrategyHandler:
    def __init__(self):
        self.parser = OptionParser()       # NLP解析器
        self.mapper = StrategyMapper()     # 策略映射器
    
    def is_option_strategy_request(self, user_input: str) -> bool:
        """快速检测是否期权策略请求"""
        keywords = ['期权', 'option', 'call', 'put', '看涨', '看跌', '策略']
        if any(kw in user_input.lower() for kw in keywords):
            return True
        
        # 检查: 股票代码 + 方向词
        has_ticker = any(t in user_input.upper() for t in ['TSLA', 'AAPL', 'NVDA'])
        has_direction = any(w in user_input for w in ['看涨', '看跌', '上涨', '下跌'])
        return has_ticker and has_direction
    
    def handle_option_strategy_request(self, user_input, current_price=None):
        """处理期权策略请求"""
        # 1. 解析意图
        intent = self.parser.parse(user_input)
        
        # 2. 检查置信度
        if intent.confidence < 0.3:
            return {'success': False, 'error': '信息不足...'}
        
        # 3. 设置默认价格
        if current_price is None:
            price_map = {'TSLA': 250.0, 'AAPL': 180.0, 'NVDA': 450.0}
            current_price = price_map.get(intent.ticker, 300.0)
        
        # 4. 映射策略
        strategy = self.mapper.map_strategy(intent, current_price)
        
        # 5. 构建返回结果
        return {
            'success': True,
            'parsed_intent': {...},
            'strategy': {...}
        }
    
    def generate_text_response(self, result):
        """生成文字形式的回复"""
        # 格式化为Markdown文本
        return """
📊 **分析结果**
标的: TSLA
方向: 看涨
...
💡 **推荐策略: 牛市价差**
...
"""
```

---

### 4. **后端 - Flask API集成**
📄 `backend/app.py`

**聊天端点中的期权策略检测**:

```python
@app.route('/api/decisions/chat', methods=['POST'])
def chat():
    data = request.json
    message = data.get('message', '')
    session_id = data.get('session_id', '')
    
    # ✅ 关键步骤: 优先检查是否是期权策略请求
    if OPTION_STRATEGY_AVAILABLE and option_handler:
        if option_handler.is_option_strategy_request(message):
            print("DEBUG: 检测到期权策略请求")
            
            # 处理期权策略
            option_result = option_handler.handle_option_strategy_request(message)
            
            if option_result['success']:
                # 生成文字回复
                text_response = option_handler.generate_text_response(option_result)
                
                # 保存聊天记录
                if session_id:
                    save_chat_message(session_id, message, text_response)
                
                # ⭐ 返回特殊格式的JSON
                return jsonify({
                    "response": text_response,              # 文字描述
                    "session_id": session_id,
                    "option_strategy_used": True,           # 标记使用了期权策略
                    "option_strategy_result": option_result # 完整策略数据
                }), 200
    
    # 否则，使用AI处理普通聊天
    # ... DeepSeek API调用 ...
```

**返回的JSON结构**:
```json
{
  "response": "📊 **分析结果**\n标的: TSLA\n方向: 看涨\n...",
  "session_id": "username",
  "option_strategy_used": true,
  "option_strategy_result": {
    "success": true,
    "parsed_intent": {
      "ticker": "TSLA",
      "direction": "bullish",
      "strength": "strong",
      "timeframe": "short",
      "risk_profile": "balanced",
      "confidence": 0.75
    },
    "strategy": {
      "name": "牛市价差",
      "type": "bull_call_spread",
      "description": "买入较低执行价看涨期权...",
      "risk_level": "中",
      "parameters": {
        "current_price": 250.0,
        "buy_strike": 250.0,
        "sell_strike": 275.0,
        "premium_paid": 10.0,
        "premium_received": 5.0,
        "expiry": "30天"
      },
      "metrics": {
        "max_loss": -500.0,
        "max_gain": 2000.0,
        "breakeven": 255.0,
        "probability": "45%"
      },
      "payoff_data": [
        {"price": 175.0, "payoff": -500.0},
        {"price": 176.5, "payoff": -500.0},
        ...
        {"price": 325.0, "payoff": 2000.0}
      ]
    }
  }
}
```

---

### 5. **前端 - 响应处理**
📄 `frontend/src/App.js`

**sendMessage函数中的检测逻辑**:

```javascript
const sendMessage = async () => {
  // 1. 发送消息到后端
  const response = await fetch(`${API_URL}/api/decisions/chat`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
      message: userMessage,
      session_id: user?.username 
    })
  });
  
  const data = await response.json();
  
  // 2. ⭐ 检查是否返回了期权策略结果
  if (data.option_strategy_used && data.option_strategy_result) {
    console.log('🎯 检测到期权策略响应:', data.option_strategy_result);
    
    // 3. 设置状态，触发模态框显示
    setOptionStrategyResult(data.option_strategy_result);
    setShowOptionStrategy(true);
  }
  
  // 4. 显示文字回复
  const updatedMessages = [...newMessages, { 
    type: 'assistant', 
    text: data.response 
  }];
  setChatMessages(updatedMessages);
  
  // 5. 保存到localStorage
  localStorage.setItem(`chat_${user.username}`, JSON.stringify(updatedMessages));
};
```

**渲染模态框**:

```javascript
return (
  <div className="App">
    {/* 聊天界面 */}
    <div className="chat-container">
      {/* ... 聊天消息 ... */}
    </div>
    
    {/* ⭐ 期权策略模态框 */}
    {showOptionStrategy && optionStrategyResult && (
      <OptionStrategy 
        optionResult={optionStrategyResult}
        onClose={() => setShowOptionStrategy(false)}
      />
    )}
  </div>
);
```

---

### 6. **前端 - 策略可视化组件**
📄 `frontend/src/OptionStrategy.js`

**功能**: 渲染期权策略的详细信息和Payoff图表

#### 组件结构:

```javascript
const OptionStrategy = ({ optionResult, onClose }) => {
  const chartRef = useRef(null);
  const chartInstance = useRef(null);
  
  const { parsed_intent, strategy } = optionResult;
  const { parameters, metrics, payoff_data } = strategy;
  
  // 1. 使用useEffect创建Chart.js图表
  useEffect(() => {
    if (chartRef.current && payoff_data) {
      const ctx = chartRef.current.getContext('2d');
      
      chartInstance.current = new Chart(ctx, {
        type: 'line',
        data: {
          labels: payoff_data.map(d => d.price.toFixed(2)),  // X轴: 股价
          datasets: [{
            label: 'Profit/Loss ($)',
            data: payoff_data.map(d => d.payoff),            // Y轴: 盈亏
            borderColor: 'rgb(75, 192, 192)',
            backgroundColor: 'rgba(75, 192, 192, 0.1)',
            // 根据盈亏值改变线条颜色
            segment: {
              borderColor: ctx => {
                const value = ctx.p1.parsed.y;
                return value >= 0 ? 'rgb(75, 192, 192)' : 'rgb(255, 99, 132)';
              }
            }
          }]
        },
        options: {
          scales: {
            x: { title: { text: 'Stock Price at Expiry ($)' } },
            y: { title: { text: 'Profit/Loss ($)' } }
          }
        }
      });
    }
    
    return () => {
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }
    };
  }, [payoff_data]);
  
  // 2. 渲染UI
  return (
    <div style={styles.overlay} onClick={onClose}>
      <div style={styles.modal} onClick={(e) => e.stopPropagation()}>
        {/* 标题 */}
        <h2>📊 期权策略推荐</h2>
        
        {/* Section 1: 识别的投资意图 */}
        <div style={styles.section}>
          <h3>🎯 识别的投资意图</h3>
          <div>标的: {parsed_intent.ticker}</div>
          <div>方向: {parsed_intent.direction}</div>
          <div>强度: {parsed_intent.strength}</div>
          <div>置信度: {parsed_intent.confidence * 100}%</div>
        </div>
        
        {/* Section 2: 推荐策略 */}
        <div style={styles.section}>
          <h3>💡 推荐策略</h3>
          <h4>{strategy.name}</h4>
          <p>{strategy.description}</p>
          <div>风险等级: {strategy.risk_level}</div>
        </div>
        
        {/* Section 3: 策略参数 */}
        <div style={styles.section}>
          <h3>📋 策略参数</h3>
          <div>当前股价: ${parameters.current_price}</div>
          <div>买入执行价: ${parameters.buy_strike}</div>
          <div>卖出执行价: ${parameters.sell_strike}</div>
          <div>支付权利金: ${parameters.premium_paid}</div>
          <div>收到权利金: ${parameters.premium_received}</div>
          <div>到期时间: {parameters.expiry}</div>
        </div>
        
        {/* Section 4: 风险指标 */}
        <div style={styles.section}>
          <h3>⚠️ 风险指标</h3>
          <div>最大收益: ${metrics.max_gain}</div>
          <div>最大损失: ${metrics.max_loss}</div>
          <div>盈亏平衡点: ${metrics.breakeven}</div>
          <div>成功概率: {metrics.probability}</div>
        </div>
        
        {/* Section 5: Payoff曲线图 ⭐ */}
        <div style={styles.section}>
          <h3>📈 Payoff 曲线图</h3>
          <div style={{ height: '350px' }}>
            <canvas ref={chartRef} />
          </div>
        </div>
        
        {/* 关闭按钮 */}
        <button onClick={onClose}>关闭</button>
      </div>
    </div>
  );
};
```

#### Chart.js配置详解:

```javascript
{
  type: 'line',  // 线图
  data: {
    // X轴标签: 股价 (101个点)
    labels: [175.00, 176.50, 178.00, ..., 325.00],
    
    datasets: [{
      label: 'Profit/Loss ($)',
      // Y轴数据: 对应的盈亏值
      data: [-500, -500, -500, ..., 2000],
      
      // 动态颜色: 盈利绿色，亏损红色
      segment: {
        borderColor: ctx => {
          const value = ctx.p1.parsed.y;
          return value >= 0 ? 'green' : 'red';
        }
      }
    }]
  },
  options: {
    scales: {
      y: {
        // Y轴添加0轴线（盈亏平衡线）
        grid: {
          color: ctx => ctx.tick.value === 0 ? 'black' : 'lightgray'
        }
      }
    }
  }
}
```

---

## 📝 完整示例

### 用户输入:
```
"我强烈看涨特斯拉，但只想承担中等风险"
```

### 处理流程:

**步骤1: NLP解析**
```python
# option_nlp_parser.parse()
ParsedIntent(
    ticker='TSLA',          # ✓ 识别到"特斯拉"
    direction='bullish',    # ✓ 识别到"看涨"
    strength='strong',      # ✓ 识别到"强烈"
    timeframe='short',      # 默认
    risk_profile='balanced', # ✓ 识别到"中等风险"
    confidence=0.85         # 高置信度
)
```

**步骤2: 策略映射**
```python
# option_strategy_mapper.map_strategy()
# 查找规则: ('bullish', 'strong', 'balanced')
strategy_config = {
    'name': '牛市价差',
    'type': 'bull_call_spread',
    'description': '买入较低执行价看涨期权，同时卖出较高执行价看涨期权。风险和收益都有限。',
    'risk': '中'
}
```

**步骤3: 参数计算**
```python
# 假设TSLA当前价格: $250
parameters = {
    'current_price': 250.0,
    'buy_strike': 250.0,      # ATM Call
    'sell_strike': 275.0,     # OTM 10% Call
    'premium_paid': 10.0,     # 买入Call支付 $10
    'premium_received': 5.0,   # 卖出Call收到 $5
    'expiry': '30天'
}
```

**步骤4: 指标计算**
```python
metrics = {
    'max_loss': -500.0,       # 最大损失 = (10-5) * 100 = $500
    'max_gain': 2000.0,       # 最大收益 = (275-250)*100 - 500 = $2000
    'breakeven': 255.0,       # 盈亏平衡 = 250 + 5 = $255
    'probability': '45%'
}
```

**步骤5: Payoff数据生成**
```python
payoff_data = [
    {'price': 175.0, 'payoff': -500.0},   # 股价<250, 损失500
    {'price': 200.0, 'payoff': -500.0},
    {'price': 250.0, 'payoff': -500.0},   # 执行价点
    {'price': 255.0, 'payoff': 0.0},      # 盈亏平衡点
    {'price': 260.0, 'payoff': 500.0},
    {'price': 275.0, 'payoff': 2000.0},   # 最大收益点
    {'price': 300.0, 'payoff': 2000.0},   # 股价>275, 收益锁定2000
    {'price': 325.0, 'payoff': 2000.0}
]
```

**步骤6: 前端显示**

文字回复:
```markdown
📊 **分析结果**
标的: TSLA
方向: 看涨
强度: strong
风险偏好: balanced
置信度: 85%

💡 **推荐策略: 牛市价差**
买入较低执行价看涨期权，同时卖出较高执行价看涨期权。风险和收益都有限。
风险等级: 中

📋 **策略参数**
当前股价: $250.00
买入执行价: $250.00
卖出执行价: $275.00
支付权利金: $10.00
收到权利金: $5.00
到期时间: 30天

⚠️ **风险指标**
最大收益: $2000.00
最大损失: $500.00
盈亏平衡点: $255.00
成功概率: 45%

📈 **Payoff曲线已生成，请查看图表了解详细的盈亏情况。**
```

图表显示:
- X轴: 股价从 $175 到 $325
- Y轴: 盈亏从 -$500 到 +$2000
- 绿线: 股价 > $255 (盈利区)
- 红线: 股价 < $255 (亏损区)
- 黑色横线: Y=0 (盈亏平衡线)

---

## 🎨 字段对应关系总结

| 字段名 | 类型 | 来源 | 作用 | 示例值 |
|--------|------|------|------|--------|
| **ticker** | string | NLP解析 | 标的股票 | "TSLA" |
| **direction** | string | NLP解析 | 看涨/跌/震荡 | "bullish" |
| **strength** | string | NLP解析 | 强度 | "strong" |
| **timeframe** | string | NLP解析 | 时间框架 | "short" |
| **risk_profile** | string | NLP解析 | 风险偏好 | "balanced" |
| **confidence** | float | NLP计算 | 解析置信度 | 0.85 |
| **name** | string | 策略映射 | 策略中文名 | "牛市价差" |
| **type** | string | 策略映射 | 策略英文标识 | "bull_call_spread" |
| **description** | string | 策略映射 | 策略描述 | "买入较低执行价..." |
| **risk_level** | string | 策略映射 | 风险等级 | "中" |
| **current_price** | float | 参数计算 | 当前股价 | 250.0 |
| **buy_strike** | float | 参数计算 | 买入执行价 | 250.0 |
| **sell_strike** | float | 参数计算 | 卖出执行价 | 275.0 |
| **premium_paid** | float | 参数计算 | 支付权利金 | 10.0 |
| **premium_received** | float | 参数计算 | 收到权利金 | 5.0 |
| **expiry** | string | 参数计算 | 到期时间 | "30天" |
| **max_loss** | float | 指标计算 | 最大损失 | -500.0 |
| **max_gain** | float | 指标计算 | 最大收益 | 2000.0 |
| **breakeven** | float | 指标计算 | 盈亏平衡点 | 255.0 |
| **probability** | string | 指标计算 | 成功概率 | "45%" |
| **payoff_data** | array | Payoff生成 | 图表数据 | [{price, payoff}...] |

---

## 🔑 关键技术点

### 1. **NLP关键词匹配**
- 使用中英文关键词字典
- 多关键词匹配累加得分
- 正则表达式提取ticker

### 2. **策略映射规则**
- 32种组合 (方向3 × 强度3 × 风险3 + 补充策略)
- 固定的参数计算公式
- ATM/OTM执行价设置

### 3. **Payoff计算**
- 股价范围: 当前价 ±30%
- 101个采样点
- 根据策略类型计算每个点的盈亏

### 4. **前后端通信**
- `option_strategy_used`: 标记字段
- `option_strategy_result`: 完整数据
- 前端根据标记显示模态框

### 5. **Chart.js可视化**
- 动态颜色渲染
- 0轴线高亮
- Tooltip格式化

---

## 📚 相关文件清单

### 后端
1. `backend/algorithms/option_nlp_parser.py` - NLP解析器
2. `backend/algorithms/option_strategy_mapper.py` - 策略映射器
3. `backend/option_strategy_handler.py` - 策略处理器
4. `backend/app.py` - Flask API集成

### 前端
5. `frontend/src/App.js` - 主应用 (sendMessage函数)
6. `frontend/src/OptionStrategy.js` - 可视化组件

---

**最后更新**: 2024-10-23  
**作者**: AI Assistant

