# æœŸæƒç­–ç•¥è¯†åˆ«ä¸å›¾è¡¨ç”Ÿæˆå®Œæ•´æµç¨‹

**åŠŸèƒ½è¯´æ˜**: åœ¨Chat Modeä¸‹ï¼Œç”¨æˆ·è¾“å…¥è‡ªç„¶è¯­è¨€ï¼ˆå¦‚"æˆ‘å¼ºçƒˆçœ‹æ¶¨ç‰¹æ–¯æ‹‰"ï¼‰ï¼Œç³»ç»Ÿè‡ªåŠ¨è¯†åˆ«æŠ•èµ„æ„å›¾ï¼Œæ¨èæœŸæƒç­–ç•¥ï¼Œå¹¶ç”Ÿæˆå¯è§†åŒ–çš„Payoffæ›²çº¿å›¾è¡¨ã€‚

---

## ğŸ“Š å®Œæ•´æ•°æ®æµç¨‹å›¾

```
ç”¨æˆ·è¾“å…¥èŠå¤©æ¶ˆæ¯
    â†“
å‰ç«¯ App.js: sendMessage()
    â†“
POST /api/decisions/chat
    â†“
åç«¯ app.py: chat() å‡½æ•°
    â†“
[æ­¥éª¤1] æ£€æµ‹æ˜¯å¦æœŸæƒç­–ç•¥è¯·æ±‚
    option_handler.is_option_strategy_request(message)
    â†“
[æ­¥éª¤2] è§£æç”¨æˆ·æ„å›¾ (NLP)
    option_nlp_parser.parse(message)
    â†’ æå–: ticker, direction, strength, timeframe, risk_profile
    â†“
[æ­¥éª¤3] æ˜ å°„åˆ°å…·ä½“ç­–ç•¥
    option_strategy_mapper.map_strategy(intent, current_price)
    â†’ æ¨èç­–ç•¥, è®¡ç®—å‚æ•°, ç”Ÿæˆpayoffæ•°æ®
    â†“
[æ­¥éª¤4] è¿”å›JSONå“åº”
    {
      "response": "æ–‡å­—æè¿°",
      "option_strategy_used": true,
      "option_strategy_result": {...}
    }
    â†“
å‰ç«¯æ¥æ”¶å“åº”
    â†“
[æ­¥éª¤5] æ˜¾ç¤ºç­–ç•¥æ¨¡æ€æ¡†
    OptionStrategy.js æ¸²æŸ“
    â†“
[æ­¥éª¤6] ç»˜åˆ¶Chart.jså›¾è¡¨
    payoff_data â†’ Chart.js å¯è§†åŒ–
```

---

## ğŸ”§ æ ¸å¿ƒæ–‡ä»¶å’ŒåŠŸèƒ½

### 1. **åç«¯ - NLPè§£æå™¨** 
ğŸ“„ `backend/algorithms/option_nlp_parser.py`

**åŠŸèƒ½**: ä»è‡ªç„¶è¯­è¨€ä¸­æå–æŠ•èµ„æ„å›¾çš„å…³é”®å­—æ®µ

#### æ ¸å¿ƒç±»: `OptionParser`

```python
class OptionParser:
    def parse(self, user_input: str) -> ParsedIntent:
        """ä¸»è§£æå‡½æ•°"""
        intent = ParsedIntent()
        
        # æå–5ä¸ªå…³é”®å­—æ®µ
        intent.ticker = self._extract_ticker(user_input)      # è‚¡ç¥¨ä»£ç 
        intent.direction = self._extract_direction(text)      # æ–¹å‘: bullish/bearish/neutral
        intent.strength = self._extract_strength(text)        # å¼ºåº¦: strong/moderate/slight  
        intent.timeframe = self._extract_timeframe(text)      # æ—¶é—´: short/medium/long
        intent.risk_profile = self._extract_risk_profile(text) # é£é™©: aggressive/balanced/conservative
        intent.confidence = self._calculate_confidence(intent) # ç½®ä¿¡åº¦
        
        return intent
```

#### å…³é”®å­—æ®µè¯†åˆ«é€»è¾‘:

**1. Ticker (è‚¡ç¥¨ä»£ç ) è¯†åˆ«**
```python
def _extract_ticker(self, text: str) -> Optional[str]:
    # æ–¹æ³•1: ä¸­æ–‡åç§°æ˜ å°„
    ticker_map = {
        'ç‰¹æ–¯æ‹‰': 'TSLA',
        'è‹¹æœ': 'AAPL',
        'è‹±ä¼Ÿè¾¾': 'NVDA',
        # ... æ›´å¤šæ˜ å°„
    }
    for name, ticker in ticker_map.items():
        if name in text:
            return ticker
    
    # æ–¹æ³•2: æ­£åˆ™åŒ¹é…å¤§å†™å­—æ¯ (å¦‚ "TSLA")
    matches = re.findall(r'\b([A-Z]{2,5})\b', text)
    if matches:
        return matches[0]
```

**2. Direction (æ–¹å‘) è¯†åˆ«**
```python
direction_keywords = {
    'bullish': ['çœ‹æ¶¨', 'çœ‹å¤š', 'ä¸Šæ¶¨', 'æ¶¨', 'çªç ´', 'long', 'call', 'ç‰›å¸‚'],
    'bearish': ['çœ‹è·Œ', 'çœ‹ç©º', 'ä¸‹è·Œ', 'è·Œ', 'short', 'put', 'ç†Šå¸‚'],
    'neutral': ['éœ‡è¡', 'æ¨ªç›˜', 'åŒºé—´', 'neutral', 'æ³¢åŠ¨']
}

def _extract_direction(self, text: str) -> str:
    scores = {'bullish': 0, 'bearish': 0, 'neutral': 0}
    for direction, keywords in direction_keywords.items():
        for keyword in keywords:
            if keyword in text:
                scores[direction] += 1
    return max(scores, key=scores.get)  # è¿”å›å¾—åˆ†æœ€é«˜çš„
```

**3. Strength (å¼ºåº¦) è¯†åˆ«**
```python
strength_keywords = {
    'strong': ['å¼ºçƒˆ', 'éå¸¸', 'æåº¦', 'å¤§å¹…', 'æš´æ¶¨', 'å¿…å®š', 'ç¡®ä¿¡'],
    'moderate': ['å¯èƒ½', 'åº”è¯¥', 'é¢„è®¡', 'æ¸©å’Œ', 'é€‚åº¦', 'ä¸€èˆ¬'],
    'slight': ['ç•¥å¾®', 'å°å¹…', 'ç¨å¾®', 'è½»å¾®', 'ä¹Ÿè®¸']
}
```

**4. Timeframe (æ—¶é—´) è¯†åˆ«**
```python
timeframe_keywords = {
    'short': ['çŸ­æœŸ', 'è¿‘æœŸ', 'æœ¬å‘¨', 'æœ¬æœˆ', '1ä¸ªæœˆ', 'å¿«é€Ÿ'],
    'medium': ['ä¸­æœŸ', 'å­£åº¦', '2-3ä¸ªæœˆ', 'å‡ ä¸ªæœˆ'],
    'long': ['é•¿æœŸ', 'å¹´åº¦', 'åŠå¹´', 'ä¸€å¹´', 'é•¿è¿œ']
}
```

**5. Risk Profile (é£é™©åå¥½) è¯†åˆ«**
```python
risk_keywords = {
    'aggressive': ['æ¿€è¿›', 'èµŒ', 'all in', 'æ¢­å“ˆ', 'é‡ä»“', 'é«˜é£é™©'],
    'balanced': ['å¹³è¡¡', 'ç¨³å¥', 'é€‚ä¸­', 'ä¸­ç­‰', 'å‡è¡¡'],
    'conservative': ['ä¿å®ˆ', 'ç¨³å¦¥', 'å®‰å…¨', 'ä½é£é™©', 'è°¨æ…']
}
```

**6. ç½®ä¿¡åº¦è®¡ç®—**
```python
def _calculate_confidence(self, intent: ParsedIntent) -> float:
    confidence = 0.0
    if intent.ticker:        confidence += 0.3  # å¿…è¦å­—æ®µ
    if intent.direction:     confidence += 0.3  # å¿…è¦å­—æ®µ
    if intent.strength:      confidence += 0.15 # å¯é€‰å­—æ®µ
    if intent.timeframe:     confidence += 0.15 # å¯é€‰å­—æ®µ
    if intent.risk_profile:  confidence += 0.1  # å¯é€‰å­—æ®µ
    return min(confidence, 1.0)
```

#### ç¤ºä¾‹:

**è¾“å…¥**: `"æˆ‘å¼ºçƒˆçœ‹æ¶¨ç‰¹æ–¯æ‹‰è‚¡ç¥¨"`

**è¾“å‡º**:
```python
ParsedIntent(
    ticker='TSLA',
    direction='bullish',
    strength='strong',
    timeframe='short',      # é»˜è®¤å€¼
    risk_profile='balanced', # é»˜è®¤å€¼
    confidence=0.75         # 0.3 + 0.3 + 0.15
)
```

---

### 2. **åç«¯ - ç­–ç•¥æ˜ å°„å™¨**
ğŸ“„ `backend/algorithms/option_strategy_mapper.py`

**åŠŸèƒ½**: æ ¹æ®è§£æçš„æ„å›¾ï¼Œæ¨èå…·ä½“çš„æœŸæƒç­–ç•¥å¹¶è®¡ç®—å‚æ•°

#### æ ¸å¿ƒç±»: `StrategyMapper`

```python
class StrategyMapper:
    def map_strategy(self, intent: ParsedIntent, current_price: float) -> OptionStrategy:
        """æ˜ å°„ç­–ç•¥çš„ä¸»å‡½æ•°"""
        
        # 1. æ ¹æ®æ„å›¾é€‰æ‹©ç­–ç•¥
        strategy_config = self._select_strategy(
            intent.direction,
            intent.strength,
            intent.risk_profile
        )
        
        # 2. è®¡ç®—ç­–ç•¥å‚æ•°
        params = self._calculate_parameters(
            strategy_config['type'],
            current_price,
            intent.timeframe
        )
        
        # 3. è®¡ç®—é£é™©æŒ‡æ ‡
        metrics = self._calculate_metrics(
            strategy_config['type'],
            params
        )
        
        # 4. ç”Ÿæˆpayoffæ›²çº¿æ•°æ®
        payoff_data = self._generate_payoff(
            strategy_config['type'],
            params
        )
        
        return OptionStrategy(...)
```

#### ç­–ç•¥æ˜ å°„è§„åˆ™ (32ç§ç»„åˆ):

```python
strategy_rules = {
    # (æ–¹å‘, å¼ºåº¦, é£é™©åå¥½): ç­–ç•¥é…ç½®
    ('bullish', 'strong', 'aggressive'): {
        'name': 'ä¹°å…¥å¹³å€¼çœ‹æ¶¨æœŸæƒ',
        'type': 'long_call',
        'description': 'é€‚åˆå¼ºçƒˆçœ‹æ¶¨ä¸”æ„¿æ„æ‰¿æ‹…é«˜é£é™©çš„æŠ•èµ„è€…ã€‚æ½œåœ¨æ”¶ç›Šæ— é™ã€‚',
        'risk': 'é«˜'
    },
    ('bullish', 'strong', 'balanced'): {
        'name': 'ç‰›å¸‚ä»·å·®',
        'type': 'bull_call_spread',
        'description': 'ä¹°å…¥è¾ƒä½æ‰§è¡Œä»·çœ‹æ¶¨æœŸæƒï¼ŒåŒæ—¶å–å‡ºè¾ƒé«˜æ‰§è¡Œä»·çœ‹æ¶¨æœŸæƒã€‚',
        'risk': 'ä¸­'
    },
    ('bullish', 'strong', 'conservative'): {
        'name': 'å–å‡ºè™šå€¼çœ‹è·ŒæœŸæƒ',
        'type': 'sell_otm_put',
        'description': 'å–å‡ºä½äºå½“å‰ä»·çš„çœ‹è·ŒæœŸæƒï¼Œæ”¶å–æƒåˆ©é‡‘ã€‚',
        'risk': 'ä¸­ä½'
    },
    # ... å…±32ç§ç»„åˆ
}
```

#### å‚æ•°è®¡ç®—ç¤ºä¾‹ (ç‰›å¸‚ä»·å·®):

```python
def _calculate_parameters(self, strategy_type, current_price, timeframe):
    params = StrategyParameters(current_price=current_price)
    
    if strategy_type == 'bull_call_spread':
        params.buy_strike = current_price        # ä¹°å…¥æ‰§è¡Œä»· = å½“å‰ä»· (ATM)
        params.sell_strike = current_price * 1.10 # å–å‡ºæ‰§è¡Œä»· = 110% (OTM)
        params.premium_paid = current_price * 0.04    # æ”¯ä»˜æƒåˆ©é‡‘ 4%
        params.premium_received = current_price * 0.02 # æ”¶åˆ°æƒåˆ©é‡‘ 2%
        params.expiry = '30å¤©' if timeframe == 'short' else '90å¤©'
    
    return params
```

#### é£é™©æŒ‡æ ‡è®¡ç®—:

```python
def _calculate_metrics(self, strategy_type, params):
    if strategy_type == 'bull_call_spread':
        net_premium = (params.premium_paid - params.premium_received) * 100
        max_loss = -net_premium  # æœ€å¤§æŸå¤± = å‡€æƒåˆ©é‡‘
        max_gain = (params.sell_strike - params.buy_strike) * 100 - net_premium
        breakeven = params.buy_strike + (params.premium_paid - params.premium_received)
        probability = "45%"
    
    return StrategyMetrics(max_loss, max_gain, breakeven, probability)
```

#### Payoffæ›²çº¿ç”Ÿæˆ:

```python
def _generate_payoff(self, strategy_type, params):
    """ç”Ÿæˆ101ä¸ªç‚¹çš„payoffæ•°æ®"""
    current_price = params.current_price
    payoff_data = []
    
    # è‚¡ä»·èŒƒå›´: å½“å‰ä»·æ ¼ Â±30%
    for i in range(101):
        stock_price = current_price * 0.7 + (current_price * 0.6 / 100) * i
        
        # è®¡ç®—è¯¥è‚¡ä»·ä¸‹çš„ç›ˆäº
        if strategy_type == 'bull_call_spread':
            # ä¹°å…¥Callçš„ç›ˆäº
            long_call_payoff = max(0, stock_price - params.buy_strike) - params.premium_paid
            # å–å‡ºCallçš„ç›ˆäº
            short_call_payoff = params.premium_received - max(0, stock_price - params.sell_strike)
            # æ€»ç›ˆäº
            total_payoff = (long_call_payoff + short_call_payoff) * 100
        
        payoff_data.append({
            'price': round(stock_price, 2),
            'payoff': round(total_payoff, 2)
        })
    
    return payoff_data
```

---

### 3. **åç«¯ - ç­–ç•¥å¤„ç†å™¨**
ğŸ“„ `backend/option_strategy_handler.py`

**åŠŸèƒ½**: æ•´åˆNLPå’Œç­–ç•¥æ˜ å°„ï¼Œæä¾›ç»Ÿä¸€æ¥å£

```python
class OptionStrategyHandler:
    def __init__(self):
        self.parser = OptionParser()       # NLPè§£æå™¨
        self.mapper = StrategyMapper()     # ç­–ç•¥æ˜ å°„å™¨
    
    def is_option_strategy_request(self, user_input: str) -> bool:
        """å¿«é€Ÿæ£€æµ‹æ˜¯å¦æœŸæƒç­–ç•¥è¯·æ±‚"""
        keywords = ['æœŸæƒ', 'option', 'call', 'put', 'çœ‹æ¶¨', 'çœ‹è·Œ', 'ç­–ç•¥']
        if any(kw in user_input.lower() for kw in keywords):
            return True
        
        # æ£€æŸ¥: è‚¡ç¥¨ä»£ç  + æ–¹å‘è¯
        has_ticker = any(t in user_input.upper() for t in ['TSLA', 'AAPL', 'NVDA'])
        has_direction = any(w in user_input for w in ['çœ‹æ¶¨', 'çœ‹è·Œ', 'ä¸Šæ¶¨', 'ä¸‹è·Œ'])
        return has_ticker and has_direction
    
    def handle_option_strategy_request(self, user_input, current_price=None):
        """å¤„ç†æœŸæƒç­–ç•¥è¯·æ±‚"""
        # 1. è§£ææ„å›¾
        intent = self.parser.parse(user_input)
        
        # 2. æ£€æŸ¥ç½®ä¿¡åº¦
        if intent.confidence < 0.3:
            return {'success': False, 'error': 'ä¿¡æ¯ä¸è¶³...'}
        
        # 3. è®¾ç½®é»˜è®¤ä»·æ ¼
        if current_price is None:
            price_map = {'TSLA': 250.0, 'AAPL': 180.0, 'NVDA': 450.0}
            current_price = price_map.get(intent.ticker, 300.0)
        
        # 4. æ˜ å°„ç­–ç•¥
        strategy = self.mapper.map_strategy(intent, current_price)
        
        # 5. æ„å»ºè¿”å›ç»“æœ
        return {
            'success': True,
            'parsed_intent': {...},
            'strategy': {...}
        }
    
    def generate_text_response(self, result):
        """ç”Ÿæˆæ–‡å­—å½¢å¼çš„å›å¤"""
        # æ ¼å¼åŒ–ä¸ºMarkdownæ–‡æœ¬
        return """
ğŸ“Š **åˆ†æç»“æœ**
æ ‡çš„: TSLA
æ–¹å‘: çœ‹æ¶¨
...
ğŸ’¡ **æ¨èç­–ç•¥: ç‰›å¸‚ä»·å·®**
...
"""
```

---

### 4. **åç«¯ - Flask APIé›†æˆ**
ğŸ“„ `backend/app.py`

**èŠå¤©ç«¯ç‚¹ä¸­çš„æœŸæƒç­–ç•¥æ£€æµ‹**:

```python
@app.route('/api/decisions/chat', methods=['POST'])
def chat():
    data = request.json
    message = data.get('message', '')
    session_id = data.get('session_id', '')
    
    # âœ… å…³é”®æ­¥éª¤: ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯æœŸæƒç­–ç•¥è¯·æ±‚
    if OPTION_STRATEGY_AVAILABLE and option_handler:
        if option_handler.is_option_strategy_request(message):
            print("DEBUG: æ£€æµ‹åˆ°æœŸæƒç­–ç•¥è¯·æ±‚")
            
            # å¤„ç†æœŸæƒç­–ç•¥
            option_result = option_handler.handle_option_strategy_request(message)
            
            if option_result['success']:
                # ç”Ÿæˆæ–‡å­—å›å¤
                text_response = option_handler.generate_text_response(option_result)
                
                # ä¿å­˜èŠå¤©è®°å½•
                if session_id:
                    save_chat_message(session_id, message, text_response)
                
                # â­ è¿”å›ç‰¹æ®Šæ ¼å¼çš„JSON
                return jsonify({
                    "response": text_response,              # æ–‡å­—æè¿°
                    "session_id": session_id,
                    "option_strategy_used": True,           # æ ‡è®°ä½¿ç”¨äº†æœŸæƒç­–ç•¥
                    "option_strategy_result": option_result # å®Œæ•´ç­–ç•¥æ•°æ®
                }), 200
    
    # å¦åˆ™ï¼Œä½¿ç”¨AIå¤„ç†æ™®é€šèŠå¤©
    # ... DeepSeek APIè°ƒç”¨ ...
```

**è¿”å›çš„JSONç»“æ„**:
```json
{
  "response": "ğŸ“Š **åˆ†æç»“æœ**\næ ‡çš„: TSLA\næ–¹å‘: çœ‹æ¶¨\n...",
  "session_id": "username",
  "option_strategy_used": true,
  "option_strategy_result": {
    "success": true,
    "parsed_intent": {
      "ticker": "TSLA",
      "direction": "bullish",
      "strength": "strong",
      "timeframe": "short",
      "risk_profile": "balanced",
      "confidence": 0.75
    },
    "strategy": {
      "name": "ç‰›å¸‚ä»·å·®",
      "type": "bull_call_spread",
      "description": "ä¹°å…¥è¾ƒä½æ‰§è¡Œä»·çœ‹æ¶¨æœŸæƒ...",
      "risk_level": "ä¸­",
      "parameters": {
        "current_price": 250.0,
        "buy_strike": 250.0,
        "sell_strike": 275.0,
        "premium_paid": 10.0,
        "premium_received": 5.0,
        "expiry": "30å¤©"
      },
      "metrics": {
        "max_loss": -500.0,
        "max_gain": 2000.0,
        "breakeven": 255.0,
        "probability": "45%"
      },
      "payoff_data": [
        {"price": 175.0, "payoff": -500.0},
        {"price": 176.5, "payoff": -500.0},
        ...
        {"price": 325.0, "payoff": 2000.0}
      ]
    }
  }
}
```

---

### 5. **å‰ç«¯ - å“åº”å¤„ç†**
ğŸ“„ `frontend/src/App.js`

**sendMessageå‡½æ•°ä¸­çš„æ£€æµ‹é€»è¾‘**:

```javascript
const sendMessage = async () => {
  // 1. å‘é€æ¶ˆæ¯åˆ°åç«¯
  const response = await fetch(`${API_URL}/api/decisions/chat`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
      message: userMessage,
      session_id: user?.username 
    })
  });
  
  const data = await response.json();
  
  // 2. â­ æ£€æŸ¥æ˜¯å¦è¿”å›äº†æœŸæƒç­–ç•¥ç»“æœ
  if (data.option_strategy_used && data.option_strategy_result) {
    console.log('ğŸ¯ æ£€æµ‹åˆ°æœŸæƒç­–ç•¥å“åº”:', data.option_strategy_result);
    
    // 3. è®¾ç½®çŠ¶æ€ï¼Œè§¦å‘æ¨¡æ€æ¡†æ˜¾ç¤º
    setOptionStrategyResult(data.option_strategy_result);
    setShowOptionStrategy(true);
  }
  
  // 4. æ˜¾ç¤ºæ–‡å­—å›å¤
  const updatedMessages = [...newMessages, { 
    type: 'assistant', 
    text: data.response 
  }];
  setChatMessages(updatedMessages);
  
  // 5. ä¿å­˜åˆ°localStorage
  localStorage.setItem(`chat_${user.username}`, JSON.stringify(updatedMessages));
};
```

**æ¸²æŸ“æ¨¡æ€æ¡†**:

```javascript
return (
  <div className="App">
    {/* èŠå¤©ç•Œé¢ */}
    <div className="chat-container">
      {/* ... èŠå¤©æ¶ˆæ¯ ... */}
    </div>
    
    {/* â­ æœŸæƒç­–ç•¥æ¨¡æ€æ¡† */}
    {showOptionStrategy && optionStrategyResult && (
      <OptionStrategy 
        optionResult={optionStrategyResult}
        onClose={() => setShowOptionStrategy(false)}
      />
    )}
  </div>
);
```

---

### 6. **å‰ç«¯ - ç­–ç•¥å¯è§†åŒ–ç»„ä»¶**
ğŸ“„ `frontend/src/OptionStrategy.js`

**åŠŸèƒ½**: æ¸²æŸ“æœŸæƒç­–ç•¥çš„è¯¦ç»†ä¿¡æ¯å’ŒPayoffå›¾è¡¨

#### ç»„ä»¶ç»“æ„:

```javascript
const OptionStrategy = ({ optionResult, onClose }) => {
  const chartRef = useRef(null);
  const chartInstance = useRef(null);
  
  const { parsed_intent, strategy } = optionResult;
  const { parameters, metrics, payoff_data } = strategy;
  
  // 1. ä½¿ç”¨useEffectåˆ›å»ºChart.jså›¾è¡¨
  useEffect(() => {
    if (chartRef.current && payoff_data) {
      const ctx = chartRef.current.getContext('2d');
      
      chartInstance.current = new Chart(ctx, {
        type: 'line',
        data: {
          labels: payoff_data.map(d => d.price.toFixed(2)),  // Xè½´: è‚¡ä»·
          datasets: [{
            label: 'Profit/Loss ($)',
            data: payoff_data.map(d => d.payoff),            // Yè½´: ç›ˆäº
            borderColor: 'rgb(75, 192, 192)',
            backgroundColor: 'rgba(75, 192, 192, 0.1)',
            // æ ¹æ®ç›ˆäºå€¼æ”¹å˜çº¿æ¡é¢œè‰²
            segment: {
              borderColor: ctx => {
                const value = ctx.p1.parsed.y;
                return value >= 0 ? 'rgb(75, 192, 192)' : 'rgb(255, 99, 132)';
              }
            }
          }]
        },
        options: {
          scales: {
            x: { title: { text: 'Stock Price at Expiry ($)' } },
            y: { title: { text: 'Profit/Loss ($)' } }
          }
        }
      });
    }
    
    return () => {
      if (chartInstance.current) {
        chartInstance.current.destroy();
      }
    };
  }, [payoff_data]);
  
  // 2. æ¸²æŸ“UI
  return (
    <div style={styles.overlay} onClick={onClose}>
      <div style={styles.modal} onClick={(e) => e.stopPropagation()}>
        {/* æ ‡é¢˜ */}
        <h2>ğŸ“Š æœŸæƒç­–ç•¥æ¨è</h2>
        
        {/* Section 1: è¯†åˆ«çš„æŠ•èµ„æ„å›¾ */}
        <div style={styles.section}>
          <h3>ğŸ¯ è¯†åˆ«çš„æŠ•èµ„æ„å›¾</h3>
          <div>æ ‡çš„: {parsed_intent.ticker}</div>
          <div>æ–¹å‘: {parsed_intent.direction}</div>
          <div>å¼ºåº¦: {parsed_intent.strength}</div>
          <div>ç½®ä¿¡åº¦: {parsed_intent.confidence * 100}%</div>
        </div>
        
        {/* Section 2: æ¨èç­–ç•¥ */}
        <div style={styles.section}>
          <h3>ğŸ’¡ æ¨èç­–ç•¥</h3>
          <h4>{strategy.name}</h4>
          <p>{strategy.description}</p>
          <div>é£é™©ç­‰çº§: {strategy.risk_level}</div>
        </div>
        
        {/* Section 3: ç­–ç•¥å‚æ•° */}
        <div style={styles.section}>
          <h3>ğŸ“‹ ç­–ç•¥å‚æ•°</h3>
          <div>å½“å‰è‚¡ä»·: ${parameters.current_price}</div>
          <div>ä¹°å…¥æ‰§è¡Œä»·: ${parameters.buy_strike}</div>
          <div>å–å‡ºæ‰§è¡Œä»·: ${parameters.sell_strike}</div>
          <div>æ”¯ä»˜æƒåˆ©é‡‘: ${parameters.premium_paid}</div>
          <div>æ”¶åˆ°æƒåˆ©é‡‘: ${parameters.premium_received}</div>
          <div>åˆ°æœŸæ—¶é—´: {parameters.expiry}</div>
        </div>
        
        {/* Section 4: é£é™©æŒ‡æ ‡ */}
        <div style={styles.section}>
          <h3>âš ï¸ é£é™©æŒ‡æ ‡</h3>
          <div>æœ€å¤§æ”¶ç›Š: ${metrics.max_gain}</div>
          <div>æœ€å¤§æŸå¤±: ${metrics.max_loss}</div>
          <div>ç›ˆäºå¹³è¡¡ç‚¹: ${metrics.breakeven}</div>
          <div>æˆåŠŸæ¦‚ç‡: {metrics.probability}</div>
        </div>
        
        {/* Section 5: Payoffæ›²çº¿å›¾ â­ */}
        <div style={styles.section}>
          <h3>ğŸ“ˆ Payoff æ›²çº¿å›¾</h3>
          <div style={{ height: '350px' }}>
            <canvas ref={chartRef} />
          </div>
        </div>
        
        {/* å…³é—­æŒ‰é’® */}
        <button onClick={onClose}>å…³é—­</button>
      </div>
    </div>
  );
};
```

#### Chart.jsé…ç½®è¯¦è§£:

```javascript
{
  type: 'line',  // çº¿å›¾
  data: {
    // Xè½´æ ‡ç­¾: è‚¡ä»· (101ä¸ªç‚¹)
    labels: [175.00, 176.50, 178.00, ..., 325.00],
    
    datasets: [{
      label: 'Profit/Loss ($)',
      // Yè½´æ•°æ®: å¯¹åº”çš„ç›ˆäºå€¼
      data: [-500, -500, -500, ..., 2000],
      
      // åŠ¨æ€é¢œè‰²: ç›ˆåˆ©ç»¿è‰²ï¼ŒäºæŸçº¢è‰²
      segment: {
        borderColor: ctx => {
          const value = ctx.p1.parsed.y;
          return value >= 0 ? 'green' : 'red';
        }
      }
    }]
  },
  options: {
    scales: {
      y: {
        // Yè½´æ·»åŠ 0è½´çº¿ï¼ˆç›ˆäºå¹³è¡¡çº¿ï¼‰
        grid: {
          color: ctx => ctx.tick.value === 0 ? 'black' : 'lightgray'
        }
      }
    }
  }
}
```

---

## ğŸ“ å®Œæ•´ç¤ºä¾‹

### ç”¨æˆ·è¾“å…¥:
```
"æˆ‘å¼ºçƒˆçœ‹æ¶¨ç‰¹æ–¯æ‹‰ï¼Œä½†åªæƒ³æ‰¿æ‹…ä¸­ç­‰é£é™©"
```

### å¤„ç†æµç¨‹:

**æ­¥éª¤1: NLPè§£æ**
```python
# option_nlp_parser.parse()
ParsedIntent(
    ticker='TSLA',          # âœ“ è¯†åˆ«åˆ°"ç‰¹æ–¯æ‹‰"
    direction='bullish',    # âœ“ è¯†åˆ«åˆ°"çœ‹æ¶¨"
    strength='strong',      # âœ“ è¯†åˆ«åˆ°"å¼ºçƒˆ"
    timeframe='short',      # é»˜è®¤
    risk_profile='balanced', # âœ“ è¯†åˆ«åˆ°"ä¸­ç­‰é£é™©"
    confidence=0.85         # é«˜ç½®ä¿¡åº¦
)
```

**æ­¥éª¤2: ç­–ç•¥æ˜ å°„**
```python
# option_strategy_mapper.map_strategy()
# æŸ¥æ‰¾è§„åˆ™: ('bullish', 'strong', 'balanced')
strategy_config = {
    'name': 'ç‰›å¸‚ä»·å·®',
    'type': 'bull_call_spread',
    'description': 'ä¹°å…¥è¾ƒä½æ‰§è¡Œä»·çœ‹æ¶¨æœŸæƒï¼ŒåŒæ—¶å–å‡ºè¾ƒé«˜æ‰§è¡Œä»·çœ‹æ¶¨æœŸæƒã€‚é£é™©å’Œæ”¶ç›Šéƒ½æœ‰é™ã€‚',
    'risk': 'ä¸­'
}
```

**æ­¥éª¤3: å‚æ•°è®¡ç®—**
```python
# å‡è®¾TSLAå½“å‰ä»·æ ¼: $250
parameters = {
    'current_price': 250.0,
    'buy_strike': 250.0,      # ATM Call
    'sell_strike': 275.0,     # OTM 10% Call
    'premium_paid': 10.0,     # ä¹°å…¥Callæ”¯ä»˜ $10
    'premium_received': 5.0,   # å–å‡ºCallæ”¶åˆ° $5
    'expiry': '30å¤©'
}
```

**æ­¥éª¤4: æŒ‡æ ‡è®¡ç®—**
```python
metrics = {
    'max_loss': -500.0,       # æœ€å¤§æŸå¤± = (10-5) * 100 = $500
    'max_gain': 2000.0,       # æœ€å¤§æ”¶ç›Š = (275-250)*100 - 500 = $2000
    'breakeven': 255.0,       # ç›ˆäºå¹³è¡¡ = 250 + 5 = $255
    'probability': '45%'
}
```

**æ­¥éª¤5: Payoffæ•°æ®ç”Ÿæˆ**
```python
payoff_data = [
    {'price': 175.0, 'payoff': -500.0},   # è‚¡ä»·<250, æŸå¤±500
    {'price': 200.0, 'payoff': -500.0},
    {'price': 250.0, 'payoff': -500.0},   # æ‰§è¡Œä»·ç‚¹
    {'price': 255.0, 'payoff': 0.0},      # ç›ˆäºå¹³è¡¡ç‚¹
    {'price': 260.0, 'payoff': 500.0},
    {'price': 275.0, 'payoff': 2000.0},   # æœ€å¤§æ”¶ç›Šç‚¹
    {'price': 300.0, 'payoff': 2000.0},   # è‚¡ä»·>275, æ”¶ç›Šé”å®š2000
    {'price': 325.0, 'payoff': 2000.0}
]
```

**æ­¥éª¤6: å‰ç«¯æ˜¾ç¤º**

æ–‡å­—å›å¤:
```markdown
ğŸ“Š **åˆ†æç»“æœ**
æ ‡çš„: TSLA
æ–¹å‘: çœ‹æ¶¨
å¼ºåº¦: strong
é£é™©åå¥½: balanced
ç½®ä¿¡åº¦: 85%

ğŸ’¡ **æ¨èç­–ç•¥: ç‰›å¸‚ä»·å·®**
ä¹°å…¥è¾ƒä½æ‰§è¡Œä»·çœ‹æ¶¨æœŸæƒï¼ŒåŒæ—¶å–å‡ºè¾ƒé«˜æ‰§è¡Œä»·çœ‹æ¶¨æœŸæƒã€‚é£é™©å’Œæ”¶ç›Šéƒ½æœ‰é™ã€‚
é£é™©ç­‰çº§: ä¸­

ğŸ“‹ **ç­–ç•¥å‚æ•°**
å½“å‰è‚¡ä»·: $250.00
ä¹°å…¥æ‰§è¡Œä»·: $250.00
å–å‡ºæ‰§è¡Œä»·: $275.00
æ”¯ä»˜æƒåˆ©é‡‘: $10.00
æ”¶åˆ°æƒåˆ©é‡‘: $5.00
åˆ°æœŸæ—¶é—´: 30å¤©

âš ï¸ **é£é™©æŒ‡æ ‡**
æœ€å¤§æ”¶ç›Š: $2000.00
æœ€å¤§æŸå¤±: $500.00
ç›ˆäºå¹³è¡¡ç‚¹: $255.00
æˆåŠŸæ¦‚ç‡: 45%

ğŸ“ˆ **Payoffæ›²çº¿å·²ç”Ÿæˆï¼Œè¯·æŸ¥çœ‹å›¾è¡¨äº†è§£è¯¦ç»†çš„ç›ˆäºæƒ…å†µã€‚**
```

å›¾è¡¨æ˜¾ç¤º:
- Xè½´: è‚¡ä»·ä» $175 åˆ° $325
- Yè½´: ç›ˆäºä» -$500 åˆ° +$2000
- ç»¿çº¿: è‚¡ä»· > $255 (ç›ˆåˆ©åŒº)
- çº¢çº¿: è‚¡ä»· < $255 (äºæŸåŒº)
- é»‘è‰²æ¨ªçº¿: Y=0 (ç›ˆäºå¹³è¡¡çº¿)

---

## ğŸ¨ å­—æ®µå¯¹åº”å…³ç³»æ€»ç»“

| å­—æ®µå | ç±»å‹ | æ¥æº | ä½œç”¨ | ç¤ºä¾‹å€¼ |
|--------|------|------|------|--------|
| **ticker** | string | NLPè§£æ | æ ‡çš„è‚¡ç¥¨ | "TSLA" |
| **direction** | string | NLPè§£æ | çœ‹æ¶¨/è·Œ/éœ‡è¡ | "bullish" |
| **strength** | string | NLPè§£æ | å¼ºåº¦ | "strong" |
| **timeframe** | string | NLPè§£æ | æ—¶é—´æ¡†æ¶ | "short" |
| **risk_profile** | string | NLPè§£æ | é£é™©åå¥½ | "balanced" |
| **confidence** | float | NLPè®¡ç®— | è§£æç½®ä¿¡åº¦ | 0.85 |
| **name** | string | ç­–ç•¥æ˜ å°„ | ç­–ç•¥ä¸­æ–‡å | "ç‰›å¸‚ä»·å·®" |
| **type** | string | ç­–ç•¥æ˜ å°„ | ç­–ç•¥è‹±æ–‡æ ‡è¯† | "bull_call_spread" |
| **description** | string | ç­–ç•¥æ˜ å°„ | ç­–ç•¥æè¿° | "ä¹°å…¥è¾ƒä½æ‰§è¡Œä»·..." |
| **risk_level** | string | ç­–ç•¥æ˜ å°„ | é£é™©ç­‰çº§ | "ä¸­" |
| **current_price** | float | å‚æ•°è®¡ç®— | å½“å‰è‚¡ä»· | 250.0 |
| **buy_strike** | float | å‚æ•°è®¡ç®— | ä¹°å…¥æ‰§è¡Œä»· | 250.0 |
| **sell_strike** | float | å‚æ•°è®¡ç®— | å–å‡ºæ‰§è¡Œä»· | 275.0 |
| **premium_paid** | float | å‚æ•°è®¡ç®— | æ”¯ä»˜æƒåˆ©é‡‘ | 10.0 |
| **premium_received** | float | å‚æ•°è®¡ç®— | æ”¶åˆ°æƒåˆ©é‡‘ | 5.0 |
| **expiry** | string | å‚æ•°è®¡ç®— | åˆ°æœŸæ—¶é—´ | "30å¤©" |
| **max_loss** | float | æŒ‡æ ‡è®¡ç®— | æœ€å¤§æŸå¤± | -500.0 |
| **max_gain** | float | æŒ‡æ ‡è®¡ç®— | æœ€å¤§æ”¶ç›Š | 2000.0 |
| **breakeven** | float | æŒ‡æ ‡è®¡ç®— | ç›ˆäºå¹³è¡¡ç‚¹ | 255.0 |
| **probability** | string | æŒ‡æ ‡è®¡ç®— | æˆåŠŸæ¦‚ç‡ | "45%" |
| **payoff_data** | array | Payoffç”Ÿæˆ | å›¾è¡¨æ•°æ® | [{price, payoff}...] |

---

## ğŸ”‘ å…³é”®æŠ€æœ¯ç‚¹

### 1. **NLPå…³é”®è¯åŒ¹é…**
- ä½¿ç”¨ä¸­è‹±æ–‡å…³é”®è¯å­—å…¸
- å¤šå…³é”®è¯åŒ¹é…ç´¯åŠ å¾—åˆ†
- æ­£åˆ™è¡¨è¾¾å¼æå–ticker

### 2. **ç­–ç•¥æ˜ å°„è§„åˆ™**
- 32ç§ç»„åˆ (æ–¹å‘3 Ã— å¼ºåº¦3 Ã— é£é™©3 + è¡¥å……ç­–ç•¥)
- å›ºå®šçš„å‚æ•°è®¡ç®—å…¬å¼
- ATM/OTMæ‰§è¡Œä»·è®¾ç½®

### 3. **Payoffè®¡ç®—**
- è‚¡ä»·èŒƒå›´: å½“å‰ä»· Â±30%
- 101ä¸ªé‡‡æ ·ç‚¹
- æ ¹æ®ç­–ç•¥ç±»å‹è®¡ç®—æ¯ä¸ªç‚¹çš„ç›ˆäº

### 4. **å‰åç«¯é€šä¿¡**
- `option_strategy_used`: æ ‡è®°å­—æ®µ
- `option_strategy_result`: å®Œæ•´æ•°æ®
- å‰ç«¯æ ¹æ®æ ‡è®°æ˜¾ç¤ºæ¨¡æ€æ¡†

### 5. **Chart.jså¯è§†åŒ–**
- åŠ¨æ€é¢œè‰²æ¸²æŸ“
- 0è½´çº¿é«˜äº®
- Tooltipæ ¼å¼åŒ–

---

## ğŸ“š ç›¸å…³æ–‡ä»¶æ¸…å•

### åç«¯
1. `backend/algorithms/option_nlp_parser.py` - NLPè§£æå™¨
2. `backend/algorithms/option_strategy_mapper.py` - ç­–ç•¥æ˜ å°„å™¨
3. `backend/option_strategy_handler.py` - ç­–ç•¥å¤„ç†å™¨
4. `backend/app.py` - Flask APIé›†æˆ

### å‰ç«¯
5. `frontend/src/App.js` - ä¸»åº”ç”¨ (sendMessageå‡½æ•°)
6. `frontend/src/OptionStrategy.js` - å¯è§†åŒ–ç»„ä»¶

---

**æœ€åæ›´æ–°**: 2024-10-23  
**ä½œè€…**: AI Assistant

